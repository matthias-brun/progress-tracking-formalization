<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Propagate (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Propagate</h1>

<span class="command">theory</span> <span class="name">Propagate</span><br/>
<span class="keyword">imports</span> <a href="Graph.html"><span class="name">Graph</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Propagate</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Graph</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;loc</span><span class="delimiter">,</span><span> </span><span class="tfree">&#39;t</span><span class="delimiter">)</span><span> </span><span>configuration</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>c_work</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;loc &#8658; &#39;t zmultiset&quot;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* worklists with not-yet-applied updates *)</span></span></span></span></span><span>
</span><span>  </span><span>c_pts</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;loc &#8658; &#39;t zmultiset&quot;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* tracked point-stamps *)</span></span></span></span></span><span>
</span><span>  </span><span>c_imp</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;loc &#8658; &#39;t zmultiset&quot;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* alive point-stamps (&quot;implications&quot;) *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;loc</span><span class="delimiter">,</span><span> </span><span class="tfree">&#39;t</span><span class="delimiter">)</span><span> </span><span>computation</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration stream&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dataflow_topology</span><span> </span><span class="delimiter">=</span><span> </span><span>flow</span><span class="delimiter">?</span><span class="delimiter">:</span><span> </span><span>graph</span><span> </span><span>summary</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>summary</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;loc &#8658; &#39;loc :: finite &#8658; &#39;sum :: {order, monoid_add} antichain&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>results_in</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t :: order &#8658; &#39;sum &#8658; &#39;t&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>results_in_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in t 0 = t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>results_in_mono_raw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t1 &#8804; t2 &#10233; s1 &#8804; s2 &#10233; results_in t1 s1 &#8804; results_in t2 s2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>followed_by_summary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in (results_in t s1) s2 = results_in t (s1 + s2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_zero_cycle</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;path loc loc xs &#10233; xs &#8800; [] &#10233; s = sum_path_weights xs &#10233; t &lt; results_in t s&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>results_in_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;t1 &#8804; t2 &#10233; results_in t1 s &#8804; results_in t2 s&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;s1 &#8804; s2 &#10233; results_in t s1 &#8804; results_in t s2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>results_in_mono_raw</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;path_summary &#8801; path_weight&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>followed_by</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;sum &#8658; &#39;sum &#8658; &#39;sum&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;followed_by &#8801; plus&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>safe</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;safe c &#8801; &#8704;loc1 loc2 t s. zcount (c_pts c loc1) t &gt; 0 &#8743; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2
                &#10230; (&#8707;t&#39;&#8804;results_in t s. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Implications are always non-negative.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_implications_nonneg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c = (&#8704;loc t. zcount (c_imp c loc) t &#8805; 0)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unchanged f c0 c1 &#8801; f c1 = f c0&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>zmset_frontier</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;zmset_frontier M &#8801; zmset_of (mset_set (set_antichain (frontier M)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>init_config</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;init_config c &#8801; &#8704;loc.
      c_imp c loc = {#}<span class="hidden">&#8681;</span><sub>z</sub> &#8743;
      c_work c loc = zmset_frontier (c_pts c loc)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>after_summary</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t zmultiset &#8658; &#39;sum antichain &#8658; &#39;t zmultiset&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;after_summary M S &#8801; (&#8721;s &#8712; set_antichain S. image_zmset (&#955;t. results_in t s) M)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>frontier_changes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t zmultiset &#8658; &#39;t zmultiset &#8658; &#39;t zmultiset&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;frontier_changes M N &#8801; zmset_frontier M - zmset_frontier N&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>next_change_multiplicity&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration &#8658; (&#39;loc, &#39;t) configuration &#8658; &#39;loc &#8658; &#39;t &#8658; int &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;next_change_multiplicity&#39; c0 c1 loc t n &#8801;
    &#8213; &#8249;n is the non-zero change in pointstamps at loc for timestamp t&#8250;
     n &#8800; 0 &#8743;
    &#8213; &#8249;change can only happen at timestamps not in advance of implication-frontier&#8250;
     (&#8707;t&#39;. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c0 loc) &#8743; t&#39; &#8804; t) &#8743;
       &#8213; &#8249;at loc, t is added to pointstamps n times&#8250;
     c1 = c0&#10631;c_pts := (c_pts c0)(loc := update_zmultiset (c_pts c0 loc) t n),
       &#8213; &#8249;worklist at loc is adjusted by frontier changes&#8250;
             c_work := (c_work c0)(loc := c_work c0 loc +
                frontier_changes (update_zmultiset (c_pts c0 loc) t n) (c_pts c0 loc))&#10632;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>next_change_multiplicity</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration &#8658; (&#39;loc, &#39;t) configuration &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;next_change_multiplicity c0 c1 &#8801; &#8707;loc t n. next_change_multiplicity&#39; c0 c1 loc t n&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cm_unchanged_worklist</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_change_multiplicity&#39; c0 c1 loc t n&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;loc&#39; &#8800; loc&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;c_work c1 loc&#39; = c_work c0 loc&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>next_change_multiplicity&#39;_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>next_propagate&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration &#8658; (&#39;loc, &#39;t) configuration &#8658; &#39;loc &#8658; &#39;t &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;next_propagate&#39; c0 c1 loc t &#8801;
    &#8213; &#8249;t is a least timestamp of all worklist entries&#8250;
      (t &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> c_work c0 loc &#8743;
      (&#8704;t&#39; loc&#39;. t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> c_work c0 loc&#39; &#10230; &#172; t&#39; &lt; t) &#8743;
      c1 = c0&#10631;c_imp := (c_imp c0)(loc := c_imp c0 loc + {#t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> c_work c0 loc. t&#39; = t#}),
              c_work := (&#955;loc&#39;.
                  &#8213; &#8249;worklist entries for t are removed from loc&#39;s worklist&#8250;
                    if loc&#39; = loc then {#t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> c_work c0 loc&#39;. t&#39; &#8800; t#}
                  &#8213; &#8249;worklists at other locations change by the loc&#39;s frontier change after adding summaries&#8250;
                    else c_work c0 loc&#39;
                           + after_summary
                               (frontier_changes (c_imp c0 loc + {#t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> c_work c0 loc. t&#39; = t#}) (c_imp c0 loc))
                               (summary loc loc&#39;))&#10632;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>next_propagate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t :: order) configuration &#8658; (&#39;loc, &#39;t) configuration &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;next_propagate c0 c1 &#8801; &#8707;loc t. next_propagate&#39; c0 c1 loc t&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;next&#39; c0 c1 = (next_propagate c0 c1 &#8744; next_change_multiplicity c0 c1 &#8744; c1 = c0)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;next s &#8801; next&#39; (shd s) (shd (stl s))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>cm_valid</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;cm_valid &#8801; nxt (&#955;s. next_change_multiplicity (shd s) (shd (stl s))) impl
                (&#955;s. next_change_multiplicity (shd s) (shd (stl s))) or nxt (holds (&#955;c. (&#8704;l. c_work c l = {#}<span class="hidden">&#8681;</span><sub>z</sub>)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>spec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t :: order) computation &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;spec &#8801; holds init_config aand alw next&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next&#39;_inv</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>case_names</span><span> </span><span>next_change_multiplicity</span><span> </span><span>next_propagate</span><span> </span><span>next_finish_init</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next&#39; c0 c1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P c0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;loc t n. P c0 &#10233; next_change_multiplicity&#39; c0 c1 loc t n &#10233; P c1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;loc t. P c0 &#10233; next_propagate&#39; c0 c1 loc t &#10233; P c1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;P c1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>next&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Auxiliary&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_change_multiplicity&#39;_unique</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8800; 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#39;. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc) &#8743; t&#39; &#8804; t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;!c&#39;. next_change_multiplicity&#39; c c&#39; loc t n&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?pointstamps&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c_pts c)(loc := update_zmultiset (c_pts c loc) t n)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?worklist&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;loc&#39;. c_work c loc&#39; + frontier_changes (?pointstamps&#39; loc&#39;) (c_pts c loc&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?c&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c&#10631;c_pts := ?pointstamps&#39;, c_work := ?worklist&#39;&#10632;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_change_multiplicity&#39; c ?c&#39; loc t n&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>next_change_multiplicity&#39;_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>configuration.equality</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ex1I</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?c&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span>  </span><span>simp</span><span class="delimiter">:</span><span> </span><span>next_change_multiplicity&#39;_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>configuration.equality</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frontier_change_zmset_frontier</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M1 - frontier M0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier M1) t = 1 &#8743; zcount (zmset_frontier M0) t = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_Diff_iff</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frontier_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;frontier {#}<span class="hidden">&#8681;</span><sub>z</sub> = {}<span class="hidden">&#8681;</span><sub>A</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer&#39;</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zmset_frontier_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zmset_frontier {#}<span class="hidden">&#8681;</span><sub>z</sub> = {#}<span class="hidden">&#8681;</span><sub>z</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_summary_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;after_summary {#}<span class="hidden">&#8681;</span><sub>z</sub> S = {#}<span class="hidden">&#8681;</span><sub>z</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>after_summary_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_summary_empty_summary</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;after_summary M {}<span class="hidden">&#8681;</span><sub>A</sub> = {#}<span class="hidden">&#8681;</span><sub>z</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>after_summary_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_frontier_diff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M - frontier N&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (frontier_changes M N) t = 1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8713;<span class="hidden">&#8681;</span><sub>A</sub> frontier N&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ac_Diff_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier M) t = 1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier N) t = 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (frontier_changes M N) t = 1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_frontier_diff&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier N - frontier M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (frontier_changes M N) t = -1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier N&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8713;<span class="hidden">&#8681;</span><sub>A</sub> frontier M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ac_Diff_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier M) t = 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier N) t = 1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (frontier_changes M N) t = -1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_mem_frontier_diff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8713;<span class="hidden">&#8681;</span><sub>A</sub> frontier M - frontier N&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8713;<span class="hidden">&#8681;</span><sub>A</sub> frontier N - frontier M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (frontier_changes M N) t = 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier N&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ac_notin_Diff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier M) t = 1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier N) t = 1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (frontier_changes M N) t = 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8713;<span class="hidden">&#8681;</span><sub>A</sub> frontier M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8713;<span class="hidden">&#8681;</span><sub>A</sub> frontier N&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ac_notin_Diff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier M) t = 0&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier N) t = 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (frontier_changes M N) t = 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (frontier_changes M N) t = 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_neg_after_summary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mset_neg M = {#} &#10233; mset_neg (after_summary M S) = {#}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>mset_neg_image_zmset</span><span> </span><span>mset_neg_sum_set</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>after_summary_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;Changes in loc&#39;s frontier are reflected in the worklist of loc&#39;.&#8250;</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_p_frontier_change</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_propagate&#39; c0 c1 loc t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;summary loc loc&#39; &#8800; {}<span class="hidden">&#8681;</span><sub>A</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c_work c1 loc&#39; =
         c_work c0 loc&#39;
          + after_summary
              (frontier_changes (c_imp c1 loc) (c_imp c0 loc))
              (summary loc loc&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>summary_self</span><span> </span><span>next_propagate&#39;_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>configuration.equality</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_summary_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;after_summary (M + N) S = after_summary M S + after_summary N S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum.distrib</span><span> </span><span>after_summary_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Invariants&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Invariant: inv_imps_work_sum&#8250;</span></span></span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;Get timestamps in frontiers of loc&#39;s predecessor locations, apply respective summaries and
    return union of results.&#8250;</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>union_frontiers</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration &#8658; &#39;loc &#8658; &#39;t zmultiset&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;union_frontiers c loc &#8801;
    (&#8721;loc&#39;&#8712;UNIV. after_summary (zmset_frontier (c_imp c loc&#39;)) (summary loc&#39; loc))&quot;</span></span></span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;Implications + worklist is equal to the frontiers of pointstamps and all preceding nodes
    (after accounting for summaries).&#8250;</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_imps_work_sum</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c &#8801;
    &#8704;loc. c_imp c loc + c_work c loc
        = zmset_frontier (c_pts c loc) + union_frontiers c loc&quot;</span></span></span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;Version with zcount is easier to reason with&#8250;</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_imps_work_sum_zcount</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum_zcount c &#8801;
    &#8704;loc t. zcount (c_imp c loc + c_work c loc) t
          = zcount (zmset_frontier (c_pts c loc) + union_frontiers c loc) t&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_imps_work_sum_zcount</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c &#10231; inv_imps_work_sum_zcount c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_imps_work_sum_zcount_def</span><span> </span><span>inv_imps_work_sum_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zmultiset_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>union_frontiers_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &#8804; zcount (union_frontiers c loc) t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mset_neg_zcount_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mset_neg_after_summary</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_p_union_frontier_change</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_propagate&#39; c0 c1 loc t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;summary loc loc&#39; &#8800; {}<span class="hidden">&#8681;</span><sub>A</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;union_frontiers c1 loc&#39; =
         union_frontiers c0 loc&#39;
          + after_summary
              (frontier_changes (c_imp c1 loc) (c_imp c0 loc))
              (summary loc loc&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zmultiset_eq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>zcount_of_mset</span><span> </span><span>image_zmset_Diff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Sum_eq_pick_changed_elem</span><span class="delimiter">[</span><span>of</span><span> </span><span>UNIV</span><span> </span><span>loc</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>after_summary_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>next_propagate&#39;_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;init_config satisfies inv_imps_work_sum&#8250;</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_imp_inv_imps_work_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init_config c &#10233; inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_imps_work_sum_def</span><span> </span><span>init_config_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;CM preserves inv_imps_work_sum&#8250;</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cm_preserves_inv_imps_work_sum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_change_multiplicity&#39; c0 c1 loc t n&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;Given CM at loc, t, we show result for loc&#39;, t&#39;&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>loc</span><span> </span><span>t</span><span> </span><span>loc&#39;</span><span> </span><span>t&#39;</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>cm&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_change_multiplicity&#39; c0 c1 loc t n&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>cm</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>next_change_multiplicity&#39;_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>cm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unchanged_imps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unchanged c_imp c0 c1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iiws&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum_zcount c0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_imps_work_sum_zcount</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>iiws&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_zcount_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>spec2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unchanged_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;union_frontiers c1 locX = union_frontiers c0 locX&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>locX</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unchanged_imps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>elems_eq_sum_eq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="comment">&#8213; &#8249;For locations other than loc nothing changes.&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>loc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc&#39; &#8800; loc&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>iiws&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_zcount_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>spec2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>loc&#39;</span><span> </span><span>t&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>loc</span><span> </span><span>cm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unchanged_worklist</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_work c1 loc&#39;) t&#39; = zcount (c_work c0 loc&#39;) t&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>loc</span><span> </span><span>cm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unchanged_frontier</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier (c_pts c1 loc&#39;)) t&#39;
       = zcount (zmset_frontier (c_pts c0       loc&#39;)) t&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>loc</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc&#39; + c_work c1 loc&#39;) t&#39;
            = zcount (zmset_frontier (c_pts c1 loc&#39;)
                + union_frontiers c1 loc&#39;) t&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>zcount_union</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span>
</span><span>          </span><span>unchanged_imps</span><span>
</span><span>          </span><span>unchanged_union</span><span>
</span><span>          </span><span>unchanged_frontier</span><span>
</span><span>          </span><span>unchanged_worklist</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>zcount_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iiws</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="comment">&#8213; &#8249;For pointstamps at location loc we make a case distinction on whether their &quot;status&quot; in
          the frontier has changed.&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>loc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc&#39; = loc&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>iiws&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_zcount_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>loc</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="comment">&#8213; &#8249;If t appeared in the frontier&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c1 loc) - frontier (c_pts c0 loc)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>t&#39;</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>mem_frontier_diff</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="comment">&#8213; &#8249;then the worklist at t increased by 1&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_work c1 loc) t&#39; = zcount (c_work c0 loc) t&#39; + 1&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>plus_minus_conv</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="comment">&#8213; &#8249;and the frontier at t increased by 1&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier (c_pts c1 loc)) t&#39;
              = zcount (zmset_frontier (c_pts c0 loc)) t&#39; + 1&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t&#39;</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>frontier_change_zmset_frontier</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="comment">&#8213; &#8249;and the sum didn&#39;t change&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>unchanged_union</span><span>
</span><span>          </span><span class="comment">&#8213; &#8249;hence, the invariant is preserved.&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc + c_work c1 loc) t&#39;
            = zcount (zmset_frontier (c_pts c1 loc)
              + union_frontiers c1 loc) t&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iiws</span><span> </span><span>unchanged_imps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="comment">&#8213; &#8249;If t disappeared from the frontier&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>t&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c0 loc) - frontier (c_pts c1 loc)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>t&#39;</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>mem_frontier_diff&#39;</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="comment">&#8213; &#8249;then the worklist at t decreased by 1&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_work c1 loc) t&#39; = zcount (c_work c0 loc) t&#39; - 1&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_Diff_iff</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="comment">&#8213; &#8249;and the frontier at t decreased by 1&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier (c_pts c1 loc)) t&#39;
              = zcount (zmset_frontier (c_pts c0 loc)) t&#39; - 1&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t&#39;</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>frontier_change_zmset_frontier</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="comment">&#8213; &#8249;and the sum didn&#39;t change&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>unchanged_union</span><span>
</span><span>          </span><span class="comment">&#8213; &#8249;hence, the invariant is preserved.&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc + c_work c1 loc) t&#39;
            = zcount (zmset_frontier (c_pts c1 loc)
              + union_frontiers c1 loc) t&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iiws</span><span> </span><span>unchanged_imps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="comment">&#8213; &#8249;If t&#39;s multiplicity in the frontier didn&#39;t change&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c1 loc) - frontier (c_pts c0 loc)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c0 loc) - frontier (c_pts c1 loc)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (frontier_changes (c_pts c1 loc) (c_pts c0 loc)) t&#39; = 0&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>not_mem_frontier_diff</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="comment">&#8213; &#8249;then the worklist at t didn&#39;t change&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_work c1 loc) t&#39; = zcount (c_work c0 loc) t&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_Diff_iff</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="comment">&#8213; &#8249;and the frontier at t didn&#39;t change&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (zmset_frontier (c_pts c1 loc)) t&#39;
            = zcount (zmset_frontier (c_pts c0 loc)) t&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ac_notin_Diff</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ac_Diff_iff</span><span> </span><span>count_mset_set</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>count_mset_set</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>finite_set_antichain</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>            </span><span class="comment">&#8213; &#8249;and the sum didn&#39;t change&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>unchanged_union</span><span>
</span><span>          </span><span class="comment">&#8213; &#8249;hence, the invariant is preserved.&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc + c_work c1 loc) t&#39;
            = zcount (zmset_frontier (c_pts c1 loc)
              + union_frontiers c1 loc) t&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iiws</span><span> </span><span>unchanged_imps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc&#39; + c_work c1 loc&#39;) t&#39;
            = zcount (zmset_frontier (c_pts c1 loc&#39;)
              + union_frontiers c1 loc&#39;) t&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc&#39; + c_work c1 loc&#39;) t&#39;
          = zcount (zmset_frontier (c_pts c1 loc&#39;)
              + union_frontiers c1 loc&#39;) t&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>inv_imps_work_sum_zcount</span><span> </span><span>inv_imps_work_sum_zcount_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;PR preserves inv_imps_work_sum&#8250;</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p_preserves_inv_imps_work_sum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_propagate&#39; c0 c1 loc t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;Given next_propagate for loc, t, we show the result for loc&#39;, t&#39;.&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>loc</span><span> </span><span>t</span><span> </span><span>loc&#39;</span><span> </span><span>t&#39;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>p&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_propagate&#39; c0 c1 loc t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>p</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>next_propagate&#39;_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unchanged_ps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unchanged c_pts c0 c1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iiws&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum_zcount c0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_imps_work_sum_zcount</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>iiws&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_zcount_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>spec2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>loc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc=loc&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>unchanged_ps</span><span>
</span><span>        </span><span class="comment">&#8213; &#8249;The t entries in loc&#39;s worklist are shifted to the implications.&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_work c1 loc) t = 0&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc) t
         = zcount (c_imp c0 loc) t + zcount (c_work c0 loc) t&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="comment">&#8213; &#8249;Since the implications of other locations don&#39;t change and loc can&#39;t have an edge to
              itself, union_frontiers at loc doesn&#39;t change.&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;union_frontiers c1 loc = union_frontiers c0 loc&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>summary_self</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>all_eq_sum_eq</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>Sum</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="comment">&#8213; &#8249;For all the other timestamps the worklist and implications don&#39;t change.&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;tX &#8800; t &#10233; zcount (c_work c1 loc) tX = zcount (c_work c0 loc) tX&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>tX</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;tX &#8800; t &#10233; zcount (c_imp c1 loc) tX = zcount (c_imp c0 loc) tX&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>tX</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc&#39; + c_work c1 loc&#39;) t&#39;
         = zcount (zmset_frontier (c_pts c1 loc&#39;) + union_frontiers c1 loc&#39;) t&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>loc</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t=t&#39;&quot;</span></span></span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>loc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc&#8800;loc&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="comment">&#8213; &#8249;The implications are unchanged at all locations other than loc.&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span>loc</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unchanged_imps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c_imp c1 loc&#39; = c_imp c0 loc&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;summary loc loc&#39; = {}<span class="hidden">&#8681;</span><sub>A</sub>&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>unchanged_ps</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>unchanged_imps</span><span>
</span><span>          </span><span class="comment">&#8213; &#8249;The worklist only changes if loc, loc&#39; are connected.&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span>loc</span><span> </span><span>sum</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c_work c1 loc&#39; = c_work c0 loc&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="comment">&#8213; &#8249;Since the implications only change at loc and loc is not connected to loc&#39;,
            union_frontiers doesn&#39;t change.&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p</span><span> </span><span>loc</span><span> </span><span>sum</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;union_frontiers c1 loc&#39; = union_frontiers c0 loc&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>all_eq_sum_eq</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>Sum</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc&#39; + c_work c1 loc&#39;) t&#39;
           = zcount (zmset_frontier (c_pts c1 loc&#39;) + union_frontiers c1 loc&#39;) t&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;summary loc loc&#39; &#8800; {}<span class="hidden">&#8681;</span><sub>A</sub>&quot;</span></span></span><span>
</span><span>          </span><span class="comment">&#8213; &#8249;union_frontiers at loc&#39; changed by whatever amount the frontier changed.&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span>
</span><span>          </span><span>unchanged_imps</span><span>
</span><span>          </span><span>unchanged_ps</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p&#39;</span><span> </span><span>sum</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;union_frontiers c1 loc&#39; =
           union_frontiers c0 loc&#39;
            + after_summary
                (zmset_frontier (c_imp c1 loc) - zmset_frontier (c_imp c0 loc))
                (summary loc loc&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>next_p_union_frontier_change</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="comment">&#8213; &#8249;The worklist at loc&#39; changed by the same amount&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p&#39;</span><span> </span><span>sum</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;c_work c1 loc&#39; =
           c_work c0 loc&#39;
            + after_summary
                (zmset_frontier (c_imp c1 loc) - zmset_frontier (c_imp c0 loc))
                (summary loc loc&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>next_p_frontier_change</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="comment">&#8213; &#8249;The two changes cancel out.&#8250;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc&#39; + c_work c1 loc&#39;) t&#39;
         = zcount (zmset_frontier (c_pts c1 loc&#39;) + union_frontiers c1 loc&#39;) t&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc&#39; + c_work c1 loc&#39;) t&#39;
         = zcount (zmset_frontier (c_pts c1 loc&#39;) + union_frontiers c1 loc&#39;) t&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_imp c1 loc&#39; + c_work c1 loc&#39;) t&#39;
         = zcount (zmset_frontier (c_pts c1 loc&#39;) + union_frontiers c1 loc&#39;) t&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc=loc&#39;&quot;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>next_propagate&#39;_def</span><span> </span><span>Let_def</span><span> </span><span>inv_imps_work_sum_zcount</span><span> </span><span>inv_imps_work_sum_zcount_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_preserves_inv_imps_work_sum</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;holds inv_imps_work_sum s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;nxt (holds inv_imps_work_sum) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span>cm_preserves_inv_imps_work_sum</span><span>
</span><span>    </span><span>p_preserves_inv_imps_work_sum</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>next&#39;_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>spec_imp_iiws</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;spec s &#10233; alw (holds inv_imps_work_sum) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>spec_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>alw_invar</span><span> </span><span>alw_mono</span><span> </span><span>holds.elims</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>holds.elims</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>init_imp_inv_imps_work_sum</span><span> </span><span>next_preserves_inv_imps_work_sum</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Invariant: inv_imp_plus_work_nonneg&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;There is never an update in the worklist that could cause implications to become negative.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_imp_plus_work_nonneg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imp_plus_work_nonneg c &#8801; &#8704;loc t. 0 &#8804; zcount (c_imp c loc) t + zcount (c_work c loc) t&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iiws_imp_iipwn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imp_plus_work_nonneg c&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>loc</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>iiws&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum_zcount c&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_imps_work_sum_zcount</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>iiws&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_zcount_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>spec2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &#8804; zcount (union_frontiers c loc) t&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>union_frontiers_nonneg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>iiws</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &#8804; zcount (c_imp c loc + c_work c loc) t&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_imp_plus_work_nonneg_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>spec_imp_iipwn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;spec s &#10233; alw (holds inv_imp_plus_work_nonneg) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spec_imp_iiws</span><span> </span><span>iiws_imp_iipwn</span><span>
</span><span>    </span><span>alw_mono</span><span> </span><span>holds_mono</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Invariant: inv_implications_nonneg&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_imp_inv_implications_nonneg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init_config c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>init_config_def</span><span> </span><span>inv_implications_nonneg_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cm_preserves_inv_implications_nonneg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_change_multiplicity&#39; c0 c1 loc t n&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>next_change_multiplicity&#39;_def</span><span> </span><span>inv_implications_nonneg_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p_preserves_inv_implications_nonneg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next_propagate&#39; c0 c1 loc t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imp_plus_work_nonneg c0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>next_propagate&#39;_def</span><span> </span><span>Let_def</span><span> </span><span>inv_implications_nonneg_def</span><span> </span><span>inv_imp_plus_work_nonneg_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_preserves_inv_implications_nonneg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;next s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;holds inv_implications_nonneg s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;holds inv_imp_plus_work_nonneg s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;nxt (holds inv_implications_nonneg) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span>cm_preserves_inv_implications_nonneg</span><span>
</span><span>    </span><span>p_preserves_inv_implications_nonneg</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>next&#39;_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw_inv_implications_nonneg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;spec s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;alw (holds inv_implications_nonneg) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec_imp_iipwn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>spec_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>alw_iff_sdrop</span><span> </span><span>alw_invar</span><span> </span><span>next_preserves_inv_implications_nonneg</span><span> </span><span>holds.elims</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>init_imp_inv_implications_nonneg</span><span> </span><span>next&#39;_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_summary_Diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;after_summary (M - N) S = after_summary M S - after_summary N S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_subtractf</span><span> </span><span>after_summary_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_zmset_frontier</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> zmset_frontier M &#10231; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obtain_frontier_elem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8804; t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>atomize_elim</span><span class="delimiter">,</span><span> </span><span>transfer</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>order_zmset_exists_foundation</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frontier_unionD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (M+N) &#10233; 0 &lt; zcount M t &#8744; 0 &lt; zcount N t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer&#39;</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ps_frontier_in_imps_wl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (zmset_frontier (c_pts c loc)) t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_imp c loc + c_work c loc) t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &#8804; zcount (union_frontiers c loc) t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>union_frontiers_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>loc</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>zcount_union</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obtain_elem_frontier</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8804; t &#8743; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_finite_set_obtain_foundation</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{s. zcount M s &gt; 0}&quot;</span></span></span><span> </span><span>t</span><span> </span><span>thesis</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>antichain_inverse</span><span> </span><span>frontier_def</span><span> </span><span>member_antichain.rep_eq</span><span>
</span><span>      </span><span>in_minimal_antichain</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obtain_elem_zmset_frontier</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8804; t &#8743; 0 &lt; zcount (zmset_frontier M) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>obtain_elem_frontier</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ps_in_imps_wl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_pts c loc) t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8804; t &#8743; 0 &lt; zcount (c_imp c loc + c_work c loc) s&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>atomize_elim</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>loc</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; u &#8804; t &#8743; u &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>obtain_elem_frontier</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_imp c loc + c_work c loc) u&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ps_frontier_in_imps_wl</span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span>loc</span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>u</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;s&#8804;t. 0 &lt; zcount (c_imp c loc + c_work c loc) s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_le_after_summary_single</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &#8804; zcount (after_summary {#t#}<span class="hidden">&#8681;</span><sub>z</sub> S) x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>zero_le_sum_single</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>after_summary_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_le_zcount_after_summary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> S &#10233; 1 &#8804; zcount (after_summary {#t#}<span class="hidden">&#8681;</span><sub>z</sub> S) (results_in t s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_zmset_single</span><span> </span><span>after_summary_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>forw_subst</span><span class="delimiter">[</span><span>of</span><span> </span><span>1</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount {#results_in t s#}<span class="hidden">&#8681;</span><sub>z</sub> (results_in t s)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_nonneg_leq_bound</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_antichain S&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;u. zcount {#results_in t u#}<span class="hidden">&#8681;</span><sub>z</sub> (results_in t s)&quot;</span></span></span><span> </span><span>_</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zero_lt_zcount_after_summary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> S &#10233; 0 &lt; zcount (after_summary {#t#}<span class="hidden">&#8681;</span><sub>z</sub> S) (results_in t s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>int_one_le_iff_zero_less</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>one_le_zcount_after_summary</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pos_zcount_after_summary</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;t. 0 &#8804; zcount M t) &#10233; 0 &lt; zcount M t &#10233; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> S &#10233; 0 &lt; zcount (after_summary M S) (results_in t s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sum_pos2</span><span> </span><span>pos_zcount_image_zmset</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span> </span><span>zcount_sum</span><span> </span><span>after_summary_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_summary_nonneg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;t. 0 &#8804; zcount M t) &#10233; 0 &#8804; zcount (after_summary M S) t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zcount_sum</span><span> </span><span>after_summary_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_summary_zmset_of_nonneg</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &#8804; zcount (after_summary (zmset_of M) S) t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mset_neg_image_zmset</span><span> </span><span>mset_neg_sum_set</span><span> </span><span>mset_neg_zcount_nonneg</span><span> </span><span>after_summary_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pos_zcount_union_frontiers</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (after_summary (zmset_frontier (c_imp c l1)) (summary l1 l2)) (results_in t s)
    &#8804; zcount (union_frontiers c l2) (results_in t s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>member_le_sum</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>pos_zcount_image_zmset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_summary_Sum_fun</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite MM &#10233; after_summary (&#8721;M&#8712;MM. f M) A = (&#8721;M&#8712;MM. after_summary (f M) A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>MM</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>after_summary_union</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_summary_obtain_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;t. 0 &#8804; zcount M t&quot;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* could prove without this assumption *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (after_summary M S) t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>t&#39;</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M t&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in t&#39; s = t&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>after_summary_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sum_pos_ex_elem_pos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ex_comm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>pos_image_zmset_obtain_pre</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_antichain</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> antichain {} &#10233; False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>empty_antichain.abs_eq</span><span> </span><span>mem_antichain_nonempty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>impWitnessPath</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;impWitnessPath c loc1 loc2 xs t = (
    path loc1 loc2 xs &#8743;
    distinct xs &#8743;
    (&#8707;t&#39;. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc1) &#8743; t = results_in t&#39; (sum_path_weights xs) &#8743;
    (&#8704;k&lt;length xs. (&#8707;t. t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c (TO (xs ! k))) &#8743; t = results_in t&#39; (sum_path_weights (take (k+1) xs))))))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impWitnessPathEx</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;loc1 xs. impWitnessPath c loc1 loc2 xs t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;path loc2 loc2 []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>path0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 = sum_path_weights []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>foldr_Nil</span><span> </span><span>list.map</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = results_in t (sum_path_weights [])&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>results_in_zero</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>impWitnessPath_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>results_in_zero</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>longestImpWitnessPath</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;longestImpWitnessPath  c loc1 loc2 xs t = (
  impWitnessPath c loc1 loc2 xs t &#8743;
  (&#8704;loc&#39; xs&#39;. impWitnessPath c loc&#39; loc2 xs&#39; t &#10230; length (xs&#39;) &#8804; length (xs)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_edges</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {(loc1,s,loc2). s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> summary loc1 loc2}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?sums</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899; ((&#955;(loc1,loc2). set_antichain (summary loc1 loc2)) ` UNIV))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite ?sums&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite ((UNIV::&#39;loc set) &#215; ?sums &#215; (UNIV::&#39;loc set))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{(loc1,s,loc2). s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> summary loc1 loc2} &#8838; ((UNIV::&#39;loc set) &#215; ?sums &#215; (UNIV::&#39;loc set))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rev_finite_subset</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>longestImpWitnessPathEx</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;loc1 xs. longestImpWitnessPath c loc1 loc2 xs t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>paths</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;paths = {(loc1, xs). impWitnessPath c loc1 loc2 xs t}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>impWitnessPathEx</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8712; paths&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p. p &#8712; paths &#10230; (length &#8728; snd) p  &lt; card {(loc1,s,loc2). s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> summary loc1 loc2} + 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>p</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8712; paths&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length &#8728; snd) p &lt; card {(loc1,s,loc2). s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> summary loc1 loc2} + 1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>paths_def</span><span> </span><span>impWitnessPath_def</span><span> </span><span>less_Suc_eq_le</span><span> </span><span>finite_edges</span><span> </span><span>path_edge</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>distinct_card</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ex_has_greatest_nat</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p &#8712; paths&#8250;</span></span></span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>paths_def</span><span> </span><span>longestImpWitnessPath_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_first_loc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;path l1 l2 xs &#10233; xs &#8800; [] &#10233; xs ! 0 = (l1&#39;,s,l2&#39;) &#10233; l1 = l1&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>l1&#39;</span><span> </span><span>s</span><span> </span><span>l2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>path.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>path0</span><span> </span><span>l1</span><span> </span><span>l2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>path</span><span> </span><span>l1</span><span> </span><span>l2</span><span> </span><span>xs</span><span> </span><span>lbl</span><span> </span><span>l3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=[]&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>path0E</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>path</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>l1&#39;</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>find_witness_from_frontier</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#39; loc1 xs. (path loc1 loc2 xs &#8743; t =  results_in t&#39; (sum_path_weights xs) &#8743;
           (t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc1) &#8744; 0 &gt; zcount (c_work c loc1) t&#39;))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>loc1</span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>longestP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;longestImpWitnessPath c loc1 loc2 xs t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>longestImpWitnessPathEx</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = results_in t&#39; (sum_path_weights xs)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;k&lt;length xs. (&#8707;t. t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c (TO (xs ! k))) &#8743; t = results_in t&#39; (sum_path_weights (take (k+1) xs))))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>longestImpWitnessPath_def</span><span> </span><span>impWitnessPath_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &gt; zcount (c_work c loc1) t&#39; &#8744;
             (t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> (zmset_frontier (c_pts c loc1) + union_frontiers c loc1))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inv_imps_work_sum_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>all_eq_sum_eq</span><span> </span><span>add_diff_cancel_right&#39;</span><span> </span><span>member_frontier_pos_zmset</span><span> </span><span>zcount_diff</span><span> </span><span>zcount_inI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>case1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &gt; zcount (c_work c loc1) t&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t&#39;</span><span> </span><span>longestP</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>impWitnessPath_def</span><span> </span><span>longestImpWitnessPath_def</span><span> </span><span>dataflow_topology_axioms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>case2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;0 &gt; zcount (c_work c loc1) t&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> (zmset_frontier (c_pts c loc1) + union_frontiers c loc1))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>case2</span><span> </span><span>cases</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>case_split2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> zmset_frontier (c_pts c loc1)) &#8744; (t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> union_frontiers c loc1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>union_frontiers_nonneg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>add_diff_cancel_right&#39;</span><span> </span><span>zcount_diff</span><span> </span><span>zcount_ne_zero_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>case2_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> zmset_frontier (c_pts c loc1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc1)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>case2_1</span><span> </span><span>mem_zmset_frontier</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t&#39;</span><span> </span><span>impWitnessPath_def</span><span> </span><span>longestImpWitnessPath_def</span><span> </span><span>dataflow_topology_axioms</span><span> </span><span>longestP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> zmset_frontier (c_pts c loc1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>case2_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub>  union_frontiers c loc1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>case_split2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>loc0</span><span> </span><span>t0</span><span> </span><span>s0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>loc0</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t0 &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc0)&quot;</span></span></span><span>
</span><span>                                          </span><span class="string"><span class="delete"><span class="delete">&quot;s0 &#8712;<span class="hidden">&#8681;</span><sub>A</sub> (summary loc0 loc1)&quot;</span></span></span><span>
</span><span>                                          </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; = results_in t0 s0&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>after_summary_def</span><span> </span><span>set_zmset_def</span><span> </span><span>zcount_sum</span><span>
</span><span>          </span><span>member_antichain.rep_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>zcount_image_zmset</span><span> </span><span>card_gt_0_iff</span><span>
</span><span>          </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>zcount_ne_zero_iff</span><span>
</span><span>          </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sum.not_neutral_contains_not_neutral</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?xs&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(loc0, s0, loc1) # xs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>path_xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;path loc1 loc2 xs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>impWitnessPath_def</span><span> </span><span>longestImpWitnessPath_def</span><span> </span><span>longestP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>is_path_xs&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;path loc0 loc2 ?xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>longestP</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>longestImpWitnessPath_def</span><span> </span><span>impWitnessPath_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>path_singleton</span><span> </span><span>path_trans</span><span> </span><span>loc0</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k&lt;length ?xs&#39;.
              results_in t0 (sum_path_weights (take (k+1) ?xs&#39;))
              &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c (TO (?xs&#39; ! k)))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k=0&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loc0</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>results_in_zero</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>loc0</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>followed_by_summary</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k-1&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>r</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>distinctxs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct xs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>longestP</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>longestImpWitnessPath_def</span><span> </span><span>impWitnessPath_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>case_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct ?xs&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* show that we have a longer longestImpWitnessPathEx &#10230; contradicition *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = results_in t0 (sum_path_weights ?xs&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>longestP</span><span> </span><span>loc0</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>longestImpWitnessPath_def</span><span> </span><span>impWitnessPath_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>followed_by_summary</span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>impPath</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;impWitnessPath c loc0 loc2 ?xs&#39; t&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_path_xs&#39;</span><span> </span><span>case_distinct</span><span> </span><span>loc0</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>impWitnessPath_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ?xs&#39; &gt; length xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; longestImpWitnessPath c loc1 loc2 xs t&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>impPath</span><span> </span><span>leD</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>longestImpWitnessPath_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>longestP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; distinct ?xs&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* show that we have a non-increasing cycle along path (loc0, s0, loc1) # xs *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>distinctxs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TO (?xs&#39; ! k) = loc0&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k &lt; length ?xs&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>in_set_conv_nth</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=0&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>path_xs</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_first_loc</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>path_xs</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>path_to_eq_from</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>xs</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i-1&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in t0 (sum_path_weights (take (k+1) ?xs&#39;)) &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc0)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>r</span><span class="delimiter">[</span><span>OF</span><span> </span><span>k</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>k</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t0 &lt; results_in t0 (sum_path_weights (take (k+1) ?xs&#39;))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_zero_cycle</span><span class="delimiter">[</span><span>of</span><span> </span><span>loc0</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;take (k+1) ?xs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_path_weights (take (k+1) ?xs&#39;)&quot;</span></span></span><span> </span><span>t0</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_path_xs&#39;</span><span> </span><span>k</span><span>  </span><span>path_take_to</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loc0</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>frontier_comparable_False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>implication_implies_pointstamp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#39; loc&#39; s. s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc&#39; loc &#8743; t &#8805; results_in t&#39; s &#8743;
               (t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc&#39;) &#8744; 0 &gt; zcount (c_work c loc&#39;) t&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>loc&#39;</span><span> </span><span>t&#39;</span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>witness</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;path loc&#39; loc xs&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;t = results_in t&#39; (sum_path_weights xs)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc&#39;) &#8744; 0 &gt; zcount (c_work c loc&#39;) t&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>find_witness_from_frontier</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc&#39; loc&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8804; (sum_path_weights xs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>witness</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>path_path_weight</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8805; results_in t&#39; s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>witness</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>results_in_mono</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>witness</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Proof of safe&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>results_in_sum_path_weights_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;results_in t (sum_path_weights (xs @ [(loc2, s, loc3)])) = results_in (results_in t (sum_path_weights xs)) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>followed_by_summary</span><span> </span><span>sum_path_weights_append_singleton</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>loc_imps_fw</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw loc loc (c_imp c loc) []&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw loc1 loc2 M xs &#10233; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> summary loc2 loc3 &#10233; distinct (xs @ [(loc2,s,loc3)]) &#10233;
   loc_imps_fw loc1 loc3 ({# results_in t s. t &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> M #} + c_imp c loc3) (xs @ [(loc2,s,loc3)])&quot;</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loc_imps_fw_conv_path</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw c loc1 loc2 M xs &#10233; path loc1 loc2 xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>loc_imps_fw.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>path.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_conv_loc_imps_fw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;path loc1 loc2 xs &#10233; distinct xs &#10233; &#8707;M. loc_imps_fw c loc1 loc2 M xs&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>path.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>path0</span><span> </span><span>l1</span><span> </span><span>l2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>loc_imps_fw.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>path</span><span> </span><span>l1</span><span> </span><span>l2</span><span> </span><span>xs</span><span> </span><span>lbl</span><span> </span><span>l3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw c l1 l2 M xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>path</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>loc_imps_fw.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>path_summary_conv_loc_imps_fw</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2 &#10233; &#8707;M xs. loc_imps_fw c loc1 loc2 M xs &#8743; sum_path_weights xs = s&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>path_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;path loc1 loc2 xs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw c loc1 loc2 M xs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_path_weights xs &#8804; s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_weight_conv_path</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_distinct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ys</span><span> </span><span>xs</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>xs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_conv_loc_imps_fw</span><span class="delimiter">[</span><span>of</span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>xs</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subseq_sum_weights_le</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_path_weights xs = s&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>le</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_path_weights xs &lt; s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>le</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>path_sum</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>path_weight_conv_path</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>image_zmset_id</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{#x. x &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> M#} = M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>equiv_zmset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite M &#10233; &#8704;x&#8712;M. 0 &#8804; f x &#10233; y &#8712; M &#10233; 0 &lt; (f y::_::ordered_comm_monoid_add) &#10233; 0 &lt; (&#8721;x&#8712;M. f x)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>M</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>finite_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; f x&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>sum_nonneg</span><span> </span><span>add_pos_nonneg</span><span> </span><span>add_nonneg_pos</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loc_imps_fw_M_in_implications</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw c loc1 loc2 M xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;loc. c_work c loc = {#}<span class="hidden">&#8681;</span><sub>z</sub>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;s. s &#8804; t &#8743; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>loc_imps_fw.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>loc</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>obtain_elem_frontier</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>M</span><span> </span><span>xs</span><span> </span><span>s</span><span> </span><span>loc3</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount {# results_in t s. t &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> M #} t &#8744; 0 &lt; zcount (c_imp c loc3) t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount {# results_in t s. t &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> M #} t&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in t&#39; s = t&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M t&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>zcount_image_zmset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vimage_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Int_iff</span><span> </span><span>mem_Collect_eq</span><span> </span><span>sum_pos_ex_elem_pos</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8804; t&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>atomize_elim</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>riu_le_rit&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in u s &#8804; t&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>results_in_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (union_frontiers c loc3) (results_in u s)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>loc2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>after_summary_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_image_zmset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>card_eq_sum</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (zmset_frontier (c_pts c loc3)) (results_in u s) + zcount (union_frontiers c loc3) (results_in u s)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>add_nonneg_pos</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>riu_le_rit&#39;</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>zcount_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>iiws</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obtain_elem_frontier</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>u&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="comment">&#8213; &#8249;Same as induction base case&#8250;</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_imp c loc3) t&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>obtain_elem_frontier</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>disj</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loc_imps_fw_M_nonneg</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw c loc1 loc2 M xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &#8804; zcount M t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>loc_imps_fw.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>add_nonneg_nonneg</span><span> </span><span>sum_nonneg</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zcount_image_zmset</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_implications_nonneg_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loc_imps_fw_implication_in_M</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw c loc1 loc2 M xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_imp c loc1) t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M (results_in t (sum_path_weights xs))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>loc_imps_fw.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>loc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>results_in_zero</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>M</span><span> </span><span>xs</span><span> </span><span>s</span><span> </span><span>loc3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M (results_in t (sum_path_weights xs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>results_in_sum_path_weights_append</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_union</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_pos_nonneg</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_image_zmset</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in t (sum_weights (map (&#955;(s, l, t). l) xs))&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>loc_imps_fw_M_nonneg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>zcount_inI</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_implications_nonneg_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;impl_safe is essentially the same as pairwise_path_safe, without worklists&#8250;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>impl_safe</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;impl_safe c &#8801; &#8704;loc1 loc2 t s. zcount (c_imp c loc1) t &gt; 0 &#8743; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2
                   &#10230; (&#8707;t&#39;. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2) &#8743; t&#39; &#8804; results_in t s)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>impl_safe</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;loc. c_work c loc = {#}<span class="hidden">&#8681;</span><sub>z</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;impl_safe c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>impl_safe_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_imp c loc1) t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8804; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>obtain_elem_frontier</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t&#39;_zcount</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_imp c loc1) t&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>member_frontier_pos_zmset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>path_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Mxs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw c loc1 loc2 M xs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_path_weights xs = s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>atomize_elim</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>path_summary_conv_loc_imps_fw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>path_sum</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M (results_in t&#39; (sum_path_weights xs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>loc_imps_fw_implication_in_M</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>Mxs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>t&#39;_zcount</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8804; results_in t&#39; (sum_path_weights xs)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>atomize_elim</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>loc_imps_fw_M_in_implications</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Mxs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>inM</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#39;. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2) &#8743; t&#39; &#8804; results_in t s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Mxs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>results_in_mono</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;Safety for states where worklist is non-empty&#8250;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cm_preserves_impl_safe</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;impl_safe c0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;next_change_multiplicity&#39; c0 c1 loc t n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;impl_safe c1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>impl_safe_def</span><span> </span><span>next_change_multiplicity&#39;_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cm_preserves_safe</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe c0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;impl_safe c0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;next_change_multiplicity&#39; c0 c1 loc t n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;safe c1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>safe</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_pts c0 loc1) t &#10233; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2
        &#10233; &#8707;t&#39;&#8804;results_in t s. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c0 loc2)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>impl_safe</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_imp c0 loc1) t &#10233; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2
        &#10233; &#8707;t&#39;. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c0 loc2) &#8743; t&#39; &#8804; results_in t s&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>impl_safe_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>imps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c_imp c1 = c_imp c0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>next_change_multiplicity&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>u</span><span> </span><span>s</span><span> </span><span class="comment">&#8213; &#8249;`safe c1` variables&#8250;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_pts c1 loc1) u&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c1 loc1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u&#39; &#8804; u&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obtain_frontier_elem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>path_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2&quot;</span></span></span><span>
</span><span>    </span><span class="comment">&#8213; &#8249;CM state changes:&#8250;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n_neq_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8800; 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#39;. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c0 loc) &#8743; t&#39; &#8804; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>pointstamps</span><span class="delimiter">:</span><span>
</span><span>           </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;loc&#39;. c_pts c1 loc&#39; =
                    (if loc&#39; = loc then update_zmultiset (c_pts c0 loc&#39;) t n
                                   else c_pts c0 loc&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#39;&#8804;results_in u s. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c1 loc2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; 0&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="comment">&#8213; &#8249;Trivial, because no new pointstamp could have appeared&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_c0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_pts c0 loc1) u&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pointstamps</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc1=loc&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t=u&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zcount_update_zmultiset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imps</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>safe</span><span class="delimiter">[</span><span>OF</span><span> </span><span>u_c0</span><span> </span><span>path_sum</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>n_neq_zero</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &gt; 0&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imps</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc=loc1&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t=u&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>impl</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>member_frontier_pos_zmset</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>impl_safe</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>path_sum</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t&#39;&#39;</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>t&#39;&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>results_in_mono</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>order_trans</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span>path_sum</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zcount_update_zmultiset</span><span> </span><span>pointstamps</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>r</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>safe_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>next_change_multiplicity&#39;_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>r</span><span class="delimiter">[</span><span>of</span><span> </span><span>loc1</span><span> </span><span>t</span><span> </span><span>s</span><span> </span><span>loc2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A better safe?&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>worklists_vacant_to</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration &#8658; &#39;t &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;worklists_vacant_to c t =
    (&#8704;loc1 loc2 s t&#39;. s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2 &#8743; t&#39; &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> c_work c loc1 &#10230; &#172; results_in t&#39; s &#8804; t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>inv_safe</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;loc, &#39;t) configuration &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;inv_safe c = (&#8704;loc1 loc2 t s. 0 &lt; zcount (c_pts c loc1) t
                            &#8743; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2
                            &#8743; worklists_vacant_to c (results_in t s)
                &#10230; (&#8707;t&#39; &#8804; results_in t s. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Intuition: Unlike safe, inv_safe should be an invariant because it only claims the safety property
(_ &#8712;A frontier (c_imp _ _)) for pointstamps that can&#39;t be modified by future propagated
updates anymore (i.e. there are no upstream worklist entries which can result in a &#8804; pointstamp).&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_frontier_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;y&#8712;#<span class="hidden">&#8681;</span><sub>z</sub>N. &#172; y &#8804; x &#10233; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (M - N) &#10231; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>in_minimal_antichain</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>diff_zero</span><span> </span><span>le_less</span><span> </span><span>mem_Collect_eq</span><span> </span><span>set_zmset_def</span><span> </span><span>zcount_diff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>worklists_vacant_to_trans</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;worklists_vacant_to c t &#10233; t&#39; &#8804; t &#10233; worklists_vacant_to c t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>worklists_vacant_to_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>order.trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loc_imps_fw_M_in_implications&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw c loc1 loc2 M xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;worklists_vacant_to c t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;s&#8804;t. s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>loc_imps_fw.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>loc</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>obtain_elem_frontier</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_def</span><span> </span><span>eq_diff_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>M</span><span> </span><span>xs</span><span> </span><span>s</span><span> </span><span>loc3</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount {# results_in t s. t &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> M #} t&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_imp c loc3) t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>atomize_elim</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in t&#39; s = t&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M t&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>zcount_image_zmset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>vimage_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Int_iff</span><span> </span><span>mem_Collect_eq</span><span> </span><span>sum_pos_ex_elem_pos</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vacant_to</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;worklists_vacant_to c t&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>worklists_vacant_to_trans</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zero_le</span><span> </span><span>results_in_mono</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>results_in_zero</span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8804; t&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>vacant_to</span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>riu_le_rit&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in u s &#8804; t&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>results_in_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (union_frontiers c loc3) (results_in u s)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>loc2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>after_summary_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_image_zmset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>card_eq_sum</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (zmset_frontier (c_pts c loc3)) (results_in u s) + zcount (union_frontiers c loc3) (results_in u s)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>add_nonneg_pos</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>riu_le_rit&#39;</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>zcount_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>iiws</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>obtain_elem_frontier</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>u&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>in_frontier_diff</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>worklists_vacant_to_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>0</span><span> </span><span>loc3</span><span> </span><span>loc3</span><span> </span><span>t&#39;</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>meta_mp</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>order_trans</span><span> </span><span>results_in_zero</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>obtain_elem_frontier</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_safe</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_safe c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_safe_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>iiws</span><span> </span><span class="delimiter">=</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>inv_imps_work_sum_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>vacant</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;worklists_vacant_to c (results_in t s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_pts c loc1) t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8804; t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>obtain_frontier_elem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zcount_wl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_work c loc1) t&#39; = 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vacant</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>worklists_vacant_to_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>0</span><span> </span><span>loc1</span><span> </span><span>loc1</span><span> </span><span>t&#39;</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.left_neutral</span><span> </span><span>order.trans</span><span> </span><span>le_plus</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>results_in_mono</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>results_in_zero</span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>zcount_ne_zero_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39;&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39;&#39; &#8804; t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>atomize_elim</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (zmset_frontier (c_pts c loc1)) t&#39; + zcount (union_frontiers c loc1) t&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>add_pos_nonneg</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>union_frontiers_nonneg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#39;&#39;. t&#39;&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc1) &#8743; t&#39;&#39; &#8804; t&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>zcount_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>iiws</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zcount_wl</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>obtain_frontier_elem</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t&#39;&#39;_zcount</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_imp c loc1) t&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>member_frontier_pos_zmset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>path_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Mxs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;loc_imps_fw c loc1 loc2 M xs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sum_path_weights xs = s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>atomize_elim</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>path_summary_conv_loc_imps_fw</span><span class="delimiter">[</span><span>OF</span><span> </span><span>path_sum</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M (results_in t&#39;&#39; (sum_path_weights xs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>loc_imps_fw_implication_in_M</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>Mxs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>t&#39;&#39;_zcount</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vacant2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;worklists_vacant_to c (results_in t&#39;&#39; (sum_weights (map (&#955;(s, l, t). l) xs)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Mxs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>results_in_mono</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>worklists_vacant_to_trans</span><span> </span><span>t&#39;&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>vacant</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8804; results_in t&#39;&#39; (sum_path_weights xs)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>atomize_elim</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>loc_imps_fw_M_in_implications&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Mxs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>vacant2</span><span> </span><span>inM</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#39;&#8804;results_in t s. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>u</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Mxs</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t&#39;&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>t&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>results_in_mono</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw_conjI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;alw P s &#10233; alw Q s &#10233; alw (&#955;s. P s &#8743; Q s) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw_inv_safe</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;spec s &#10233; alw (holds inv_safe) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>spec_imp_iiws</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>alw_inv_implications_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>alw_mp</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>&#966;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;s. holds inv_imps_work_sum s &#8743; holds inv_implications_nonneg s&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>alw_conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>alw_mono</span><span> </span><span>inv_safe</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_worklists_vacant_to</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;loc. c_work c loc = {#}<span class="hidden">&#8681;</span><sub>z</sub> &#10233; worklists_vacant_to c t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>worklists_vacant_to_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_safe_safe</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;loc. c_work c loc = {#}<span class="hidden">&#8681;</span><sub>z</sub>) &#10233; inv_safe c &#10233; safe c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_safe_def</span><span> </span><span>safe_def</span><span> </span><span>worklists_vacant_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;loc. c_work c loc = {#}<span class="hidden">&#8681;</span><sub>z</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;safe c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv_safe_safe</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>inv_safe</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The algorithm computes the frontier implied by the pointstamps&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>zmset_pos</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zmset_pos M &#8801; zmset_of (mset_pos M)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>implied_frontier</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;implied_frontier P loc = frontier (&#8721;loc&#39;&#8712;UNIV. after_summary (zmset_pos (P loc&#39;)) (path_summary loc&#39; loc))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>implied_frontier_alt</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;implied_frontier_alt c loc = frontier (&#8721;loc&#39;&#8712;UNIV. after_summary (zmset_frontier (c_pts c loc&#39;)) (path_summary loc&#39; loc))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_frontier_least</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M &#10233; &#8704;y. 0 &lt; zcount M y &#10230; &#172; y &lt; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer&#39;</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_frontier_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount M y &#10233; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M &#10233; y &#8804; x &#10233; y &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_less</span><span> </span><span>minimal_antichain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>implied_frontier_alt_least</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> implied_frontier_alt c loc2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;loc a&#39; s&#39;. a&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc) &#10230; s&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc loc2 &#10230; &#172; results_in a&#39; s&#39; &lt; b&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>loc</span><span> </span><span>a&#39;</span><span> </span><span>s&#39;</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>s&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc loc2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a&#39; s&#39; &lt; b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (after_summary (zmset_frontier (c_pts c loc)) (path_summary loc loc2)) (results_in a&#39; s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a&#39;</span><span> </span><span>s&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>pos_zcount_after_summary</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (&#8721;loc&#39;&#8712;UNIV. after_summary (zmset_frontier (c_pts c loc&#39;)) (path_summary loc&#39; loc2)) (results_in a&#39; s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span> </span><span class="delimiter">=</span><span> </span><span>loc</span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a&#39; s&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> implied_frontier_alt c loc2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>lt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>implied_frontier_alt_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_frontier_trans</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a&#39; s&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>lt</span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>implied_frontier_alt_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>frontier_comparable_False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>implied_frontier_alt_in_pointstamps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> implied_frontier_alt c loc2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span>loc1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a s = b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>implied_frontier_alt_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>member_frontier_pos_zmset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>sum_pos_ex_elem_pos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>after_summary_obtain_pre</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>loc1</span><span> </span><span>a</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>loc1</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_implied_frontier_alt_in_implication_frontier</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;worklists_vacant_to c b&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> implied_frontier_alt c loc2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>safe</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_pts c loc1) t &#10233; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2 &#10233; results_in t s &#8804; b
        &#10233; &#8707;t&#39;&#8804;results_in t s. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv_safe</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>inv_safe_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>worklists_vacant_to_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;Pointstamp b in the implied_frontier_alt is caused by a pointstamp a and summary s
          and &quot;results_in a s&quot; is least among such pointstamps&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>loc1</span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>loc1_a_s</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a s = b&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;loc a&#39; s&#39;. a&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc) &#10230; s&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc loc2 &#10230; &#172; results_in a&#39; s&#39; &lt; b&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>implied_frontier_alt_in_pointstamps</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>implied_frontier_alt_least</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zcount_ps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_pts c loc1) a&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>member_frontier_pos_zmset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;From `safe` we know that pointstamp a is reflected in the implications by some
      poinstamp b&#39; &#8804; b&#8250;</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8804; results_in a s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe</span><span class="delimiter">[</span><span>OF</span><span> </span><span>zcount_ps</span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; = results_in a s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_work c loc) t = 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in t s &#8804; b&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span> </span><span>s</span><span> </span><span>loc</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in t s &#8804; b&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>results_in_mono</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>worklists_vacant_to_def</span><span> </span><span>flow.zero_le</span><span> </span><span>order_trans</span><span>
</span><span>          </span><span>path_weight_refl</span><span> </span><span>zcount_inI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="comment">&#8213; &#8249;but the pointstamp can&#39;t be strictly less, because we know that &quot;results_in a s&quot; is least&#8250;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a&#39;</span><span> </span><span>loc1&#39;</span><span> </span><span>s&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a&#39;</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1&#39; loc2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a&#39; s&#39; &#8804; b&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc1&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>implication_implies_pointstamp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>b&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8800; results_in a s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b&#39;_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &lt; results_in a s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>a&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b&#39;_lt</span><span> </span><span>a&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>leD</span><span> </span><span>less_le</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;Hence, the implied_frontier_alt pointstamp b is reflected in the implications&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b&#39;</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_implication_frontier_in_implied_frontier_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;worklists_vacant_to c b&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> implied_frontier_alt c loc2&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>safe</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_pts c loc1) t &#10233; s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2 &#10233; results_in t s &#8804; b
        &#10233; &#8707;t&#39;&#8804;results_in t s. t&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>loc1</span><span> </span><span>loc2</span><span> </span><span>t</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv_safe</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>inv_safe_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>worklists_vacant_to_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zcount (c_work c loc) t = 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in t s &#8804; b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span> </span><span>s</span><span> </span><span>loc</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>results_in_mono</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>worklists_vacant_to_def</span><span> </span><span>flow.zero_le</span><span>
</span><span>      </span><span>order_trans</span><span> </span><span>path_weight_refl</span><span> </span><span>zcount_inI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;Pointstamp b in the implications is caused by a pointstamp a and a summary s&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>loc1</span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>loc1_a_s</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> path_summary loc1 loc2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a s &#8804; b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_pts c loc1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>implication_implies_pointstamp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zcount_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (c_pts c loc1) a&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>member_frontier_pos_zmset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b_ria</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a s = b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a s &#8800; b&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a s &lt; b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe</span><span class="delimiter">[</span><span>OF</span><span> </span><span>zcount_a</span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dual_order.strict_trans2</span><span> </span><span>frontier_comparable_False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="comment">&#8213; &#8249;`results_in a s` is a candidate for inclusion in the implied_frontier_alt..&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 &lt; zcount (&#8721;loc&#39;&#8712;UNIV. after_summary (zmset_frontier (c_pts c loc&#39;)) (path_summary loc&#39; loc2)) (results_in a s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>after_summary_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>loc1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_image_zmset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span> </span><span class="delimiter">[</span><span>3</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>zcount_image_zmset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_pos</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;..which means a pointstamp b&#39; &#8804; results_in a s must exist in the implied_frontier_alt..&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> implied_frontier_alt c loc2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8804; results_in a s&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>implied_frontier_alt_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>obtain_frontier_elem</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;worklists_vacant_to c b&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loc1_a_s</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>worklists_vacant_to_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b&#39;</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b&#39;_frontier</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_implied_frontier_alt_in_implication_frontier</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;..and this pointstamp must be equal to b&#39;&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b&#39;_ria</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; = results_in a s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &#8800; results_in a s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b&#39;_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#39; &lt; results_in a s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b&#39;_frontier</span><span> </span><span>b&#39;_lt</span><span> </span><span>b_ria</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>frontier_comparable_False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;Hence, the implication frontier pointstamp b is reflected in the implied_frontier_alt&#8250;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b&#39;</span><span> </span><span>b&#39;_ria</span><span> </span><span>b_ria</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> implied_frontier_alt c loc2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>implied_frontier_alt_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>implication_frontier_iff_implied_frontier_alt_vacant</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;worklists_vacant_to c b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc) &#10231; b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> implied_frontier_alt c loc&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>    </span><span>ac_eq_iff</span><span>
</span><span>    </span><span>in_implication_frontier_in_implied_frontier_alt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>    </span><span>in_implied_frontier_alt_in_implication_frontier</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>next_propagate_implied_frontier_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;next_propagate c c&#39; &#10233; implied_frontier_alt c loc = implied_frontier_alt c&#39; loc&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>next_propagate&#39;_def</span><span> </span><span>implied_frontier_alt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>implication_frontier_eq_implied_frontier_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_imps_work_sum c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;inv_implications_nonneg c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;loc. c_work c loc = {#}<span class="hidden">&#8681;</span><sub>z</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;frontier (c_imp c loc) = implied_frontier_alt c loc&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ac_eq_iff</span><span> </span><span>implication_frontier_iff_implied_frontier_alt_vacant</span><span> </span><span>empty_worklists_vacant_to</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw_implication_frontier_eq_implied_frontier_alt_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;spec s &#10233;
  alw (holds (&#955;c. (&#8704;loc. c_work c loc = {#}<span class="hidden">&#8681;</span><sub>z</sub>) &#10230; frontier (c_imp c loc) = implied_frontier_alt c loc)) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>spec_imp_iiws</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>alw_inv_implications_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>alw_conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>thin_rl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>alw_mono</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>implication_frontier_eq_implied_frontier_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alw_implication_frontier_eq_implied_frontier_alt_vacant</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;spec s &#10233;
  alw (holds (&#955;c. worklists_vacant_to c b &#10230; b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier (c_imp c loc) &#10231; b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> implied_frontier_alt c loc)) s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>spec_imp_iiws</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>alw_inv_implications_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>alw_conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>thin_rl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>alw_mono</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>implication_frontier_iff_implied_frontier_alt_vacant</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>antichain_eqI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;b. b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> A &#10231; b &#8712;<span class="hidden">&#8681;</span><sub>A</sub> B) &#10233; A = B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zmset_frontier_zmset_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zmset_frontier A &#8838;#<span class="hidden">&#8681;</span><sub>z</sub> zmset_pos A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subseteq_zmset_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer&#39;</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_mset_set_if</span><span> </span><span>minimal_antichain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>image_mset_mono_pos</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;b. 0 &#8804; zcount A b &#10233; &#8704;b. 0 &#8804; zcount B b &#10233; A &#8838;#<span class="hidden">&#8681;</span><sub>z</sub> B &#10233; image_zmset f A &#8838;#<span class="hidden">&#8681;</span><sub>z</sub> image_zmset f B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subseteq_zmset_def</span><span> </span><span>zcount_image_zmset</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sum_mono</span><span> </span><span>sum_mono2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Int_subset_iff</span><span> </span><span>antisym</span><span> </span><span>subsetI</span><span> </span><span>zcount_ne_zero_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_mono_subseteq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;i. i&#8712;K &#10233; f i &#8838;#<span class="hidden">&#8681;</span><sub>z</sub> g i) &#10233; (&#8721;i&#8712;K. f i) &#8838;#<span class="hidden">&#8681;</span><sub>z</sub> (&#8721;i&#8712;K. g i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subseteq_zmset_def</span><span> </span><span>sum_mono</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>after_summary_zmset_frontier</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;after_summary (zmset_frontier A) S &#8838;#<span class="hidden">&#8681;</span><sub>z</sub> after_summary (zmset_pos A) S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>after_summary_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_mono_subseteq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>image_mset_mono_pos</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>zmset_frontier_zmset_pos</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frontier_eqI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;b. 0 &#8804; zcount A b &#10233; &#8704;b. 0 &#8804; zcount B b &#10233;
  A &#8838;#<span class="hidden">&#8681;</span><sub>z</sub> B &#10233; (&#8896;b. b &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> B &#10233; &#8707;a. a &#8712;#<span class="hidden">&#8681;</span><sub>z</sub> A &#8743; a &#8804; b) &#10233; frontier A = frontier B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span> </span><span>subseteq_zmset_def</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_le</span><span> </span><span>less_le_trans</span><span> </span><span>zcount_ne_zero_iff</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>antisym</span><span> </span><span>less_le</span><span> </span><span>zcount_ne_zero_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>implied_frontier_implied_frontier_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;implied_frontier (c_pts c) loc = implied_frontier_alt c loc&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>implied_frontier_alt_def</span><span> </span><span>implied_frontier_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>frontier_eqI</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zcount_sum</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>zcount_sum</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_mono_subseteq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>after_summary_zmset_frontier</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>zcount_ne_zero_iff</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sum.not_neutral_contains_not_neutral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>zcount_ne_zero_iff</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>after_summary_def</span><span> </span><span>zcount_sum</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sum.not_neutral_contains_not_neutral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>zcount_ne_zero_iff</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zcount_image_zmset</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>sum.not_neutral_contains_not_neutral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>zcount_ne_zero_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>u</span><span> </span><span>loc</span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>obtain_elem_frontier</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c_pts c loc&quot;</span></span></span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_less</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;results_in a s&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>results_in_mono</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_nonneg_eq_0_iff</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sum_nonneg</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>loc</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>sum_nonneg_eq_0_iff</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>s</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>alw_implication_frontier_eq_implied_frontier_vacant</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>alw_implication_frontier_eq_implied_frontier_alt_vacant</span><span class="delimiter">[</span><span>folded</span><span> </span><span>implied_frontier_implied_frontier_alt</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>implication_frontier_iff_implied_frontier_vacant</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>implication_frontier_iff_implied_frontier_alt_vacant</span><span class="delimiter">[</span><span>folded</span><span> </span><span>implied_frontier_implied_frontier_alt</span><span class="delimiter">]</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
