<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Antichain (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Antichain</h1>

<span class="command">theory</span> <span class="name">Antichain</span><br/>
<span class="keyword">imports</span> <a href="Auxiliary.html"><span class="name">Auxiliary</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Antichain</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Auxiliary</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Antichain&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>incomparable</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;incomparable A = (&#8704;x &#8712; A. &#8704;y &#8712; A. x &#8800; y &#10230; &#172; x &lt; y &#8743; &#172; y &lt; x)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>incomparable_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;incomparable {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>incomparable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="delimiter">)</span><span> </span><span class="tfree">&#39;sum</span><span> </span><span class="delimiter">::</span><span> </span><span>order</span><span> </span><span>antichain</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{A :: &#39;sum set. finite A &#8743; incomparable A}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">morphisms</span></span><span> </span><span>set_antichain</span><span> </span><span>antichain</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_antichain</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>member_antichain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;sum :: order &#8658; &#39;sum antichain &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(_/ &#8712;<span class="hidden">&#8681;</span><sub>A</sub> _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Set.member&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>not_member_antichain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;sum :: order &#8658; &#39;sum antichain &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(_/ &#8713;<span class="hidden">&#8681;</span><sub>A</sub> _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8713;<span class="hidden">&#8681;</span><sub>A</sub> A &#8801; &#172; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> A&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>empty_antichain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;sum :: order antichain&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;{}<span class="hidden">&#8681;</span><sub>A</sub>&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_antichain_nonempty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> A &#10233; A &#8800; {}<span class="hidden">&#8681;</span><sub>A</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;minimal_antichain A = {x &#8712; A. &#172;(&#8707;y &#8712; A. y &lt; x)}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_minimal_antichain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; minimal_antichain A &#10231; x &#8712; A &#8743; &#172;(&#8707;y &#8712; A. y &lt; x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>minimal_antichain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_antichain_minimal_antichain</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite M &#10233; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> antichain (minimal_antichain M) &#10231; x &#8712; minimal_antichain M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span> </span><span>member_antichain.rep_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>antichain_inverse</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>incomparable_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>antichain_inverse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>incomparable_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>antichain_inverse</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>incomparable_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>incomparable_minimal_antichain</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;incomparable (minimal_antichain A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>incomparable_def</span><span> </span><span>minimal_antichain_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_minimal_antichain</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite A &#10233; finite (minimal_antichain A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>minimal_antichain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_set_antichain</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (set_antichain A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minimal_antichain_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;minimal_antichain A &#8838; A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>minimal_antichain_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>frontier</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;t :: order zmultiset &#8658; &#39;t antichain&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;M. minimal_antichain {t. zcount M t &gt; 0}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>minimal_antichain_subset</span><span> </span><span>finite_zcount_pos</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>member_frontier_pos_zmset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M &#10233; 0 &lt; zcount M t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>frontier_def</span><span> </span><span>in_minimal_antichain</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frontier_comparable_False</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M &#10233; y &#8712;<span class="hidden">&#8681;</span><sub>A</sub> frontier M &#10233; x &lt; y &#10233; False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minimal_antichain_idempotent</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;minimal_antichain (minimal_antichain A) = minimal_antichain A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>antichain</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>order</span><span class="delimiter">)</span><span> </span><span>minus</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>minus_antichain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a antichain &#8658; &#39;a antichain &#8658; &#39;a antichain&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(-)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incomparable_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>antichain</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>order</span><span class="delimiter">)</span><span> </span><span>plus</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>plus_antichain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a antichain &#8658; &#39;a antichain &#8658; &#39;a antichain&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;M N. minimal_antichain (M &#8746; N)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incomparable_def</span><span> </span><span>minimal_antichain_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>antichain_add_commute</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(M :: &#39;a :: order antichain) + N = N + M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incomparable_def</span><span> </span><span>sup_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>filter_antichain</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;sum :: order &#8658; bool) &#8658; &#39;sum antichain &#8658; &#39;sum antichain&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Set.filter&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>incomparable_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span> </span><span class="delimiter">(</span><span>ASCII</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_ACCollect&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pttrn &#8658; &#39;sum :: order antichain &#8658; bool &#8658; &#39;sum antichain&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(1{_ :<span class="hidden">&#8681;</span><sub>A</sub> _./ _})&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;_ACCollect&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pttrn &#8658; &#39;sum :: order antichain &#8658; bool &#8658; &#39;sum antichain&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(1{_ &#8712;<span class="hidden">&#8681;</span><sub>A</sub> _./ _})&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> M. P}&quot;</span></span></span><span> </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONST filter_antichain (&#955;x. P) M&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>empty_antichain.rep_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minimal_antichain_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;minimal_antichain {} = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minimal_antichain_singleton</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;minimal_antichain {x::_ ::order} = {x}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minimal_antichain_nonempty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite A &#10233; (t::_::order) &#8712; A &#10233; minimal_antichain A &#8800; {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>order_finite_set_exists_foundation</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minimal_antichain_member</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite A &#10233; (t::_::order) &#8712; A &#10233; &#8707;t&#39;. t&#39; &#8712; minimal_antichain A &#8743; t&#39; &#8804; t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>order_finite_set_exists_foundation</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minimal_antichain_union</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;minimal_antichain ((A::(_ :: order) set) &#8746; B) &#8838; minimal_antichain (minimal_antichain A &#8746; minimal_antichain B)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>minimal_antichain_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ac_Diff_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8712;<span class="hidden">&#8681;</span><sub>A</sub> A - B &#10231; c &#8712;<span class="hidden">&#8681;</span><sub>A</sub> A &#8743; c &#8713;<span class="hidden">&#8681;</span><sub>A</sub> B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ac_DiffD2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8712;<span class="hidden">&#8681;</span><sub>A</sub> A - B &#10233; c &#8712;<span class="hidden">&#8681;</span><sub>A</sub> B &#10233; P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ac_notin_Diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> A - B &#10233; &#172; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> A &#8744; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ac_eq_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A = B &#10231; (&#8704;x. x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> A &#10231; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> B)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>antichain_obtain_foundation</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8712;<span class="hidden">&#8681;</span><sub>A</sub> M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712;<span class="hidden">&#8681;</span><sub>A</sub> M &#8743; s &#8804; t &#8743; (&#8704;u. u&#8712;<span class="hidden">&#8681;</span><sub>A</sub>M &#10230; &#172; u &lt; s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>member_antichain.rep_eq</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_finite_set_obtain_foundation</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_antichain M&quot;</span></span></span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_antichain1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; set_antichain X &#10233; x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_antichain2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712;<span class="hidden">&#8681;</span><sub>A</sub> X &#10233; x &#8712; set_antichain X&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
